#!/usr/bin/env node
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface Message {
  role: 'user' | 'assistant';
  content: any;
  timestamp?: string;
  type?: string;
  toolUseResult?: any;
  message?: any;
}

interface StateTracker {
  lastProcessedTimestamp: string;
}

interface ConversationItem {
  timestamp: string;
  role: 'user' | 'assistant';
  content: string;
  toolsUsed?: string[];
  filesModified?: string[];
}

const CLAUDE_HOME = path.join(os.homedir(), '.claude');
const STATE_FILE = '.session-doc-state.json';

/**
 * 현재 프로젝트의 대화 세션 파일 경로를 찾습니다
 */
function findProjectSessionFiles(projectPath: string): string[] {
  const normalizedPath = projectPath.replace(/[/.]/g, '-');
  const projectDir = path.join(CLAUDE_HOME, 'projects', normalizedPath);

  if (!fs.existsSync(projectDir)) {
    return [];
  }

  const files = fs.readdirSync(projectDir);
  const sessionFiles = files
    .filter(f => f.endsWith('.jsonl') && !f.startsWith('agent-'))
    .map(f => path.join(projectDir, f))
    .filter(f => fs.statSync(f).size > 0);

  return sessionFiles;
}

/**
 * JSONL 파일에서 메시지들을 읽어옵니다
 */
function readMessages(filePath: string, lastTimestamp?: string): Message[] {
  const messages: Message[] = [];
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.trim().split('\n').filter(line => line.trim());

  for (const line of lines) {
    try {
      const msg = JSON.parse(line);

      if (lastTimestamp && msg.timestamp) {
        const msgTime = new Date(msg.timestamp).getTime();
        const lastTime = new Date(lastTimestamp).getTime();
        if (msgTime <= lastTime) {
          continue;
        }
      }

      messages.push(msg);
    } catch (e) {
      continue;
    }
  }

  return messages;
}

/**
 * 시스템 태그를 제거합니다
 */
function removeSystemTags(text: string): string {
  const patterns = [
    /<ide_opened_file>[\s\S]*?<\/ide_opened_file>/g,
    /<ide_selection>[\s\S]*?<\/ide_selection>/g,
    /<system-reminder>[\s\S]*?<\/system-reminder>/g,
    /<user-prompt-submit-hook>[\s\S]*?<\/user-prompt-submit-hook>/g,
    /<command-message>[\s\S]*?<\/command-message>/g,
    /<command-name>[\s\S]*?<\/command-name>/g,
    /<command-args>[\s\S]*?<\/command-args>/g,
    /<local-command-stdout>[\s\S]*?<\/local-command-stdout>/g,
    /\[Request interrupted by user.*?\]/g,
    /Caveat: The messages below were generated by.*?explicitly asks you to\./g,
  ];

  let cleaned = text;
  for (const pattern of patterns) {
    cleaned = cleaned.replace(pattern, '');
  }

  return cleaned.trim();
}

/**
 * 무의미한 메시지인지 확인합니다
 */
function isNoiseMessage(text: string): boolean {
  if (!text || text.length === 0) return true;

  const noisePatterns = [
    /^#\s*\/session-doc/,
    /^#\s*\/[\w-]+/,
    /^\[Request interrupted/,
    /^Caveat: The messages below/,
  ];

  return noisePatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * 메시지에서 텍스트 콘텐츠를 추출합니다
 */
function extractTextContent(message: Message): string | undefined {
  const content = message.message?.content || message.content;

  if (typeof content === 'string') {
    return removeSystemTags(content);
  }

  if (Array.isArray(content)) {
    const textContent = content
      .filter(c => c.type === 'text')
      .map(c => c.text)
      .join('\n');

    if (textContent.trim()) {
      return removeSystemTags(textContent);
    }
  }

  return undefined;
}

/**
 * 파일 경로에서 파일명만 추출합니다
 */
function getFileName(filePath: string): string {
  return path.basename(filePath);
}

/**
 * 도구 호출에서 파일 정보를 추출합니다
 */
function extractToolInfo(message: Message): { tools: string[], files: string[] } {
  const tools: string[] = [];
  const files: string[] = [];

  if (message.message?.content && Array.isArray(message.message.content)) {
    for (const item of message.message.content) {
      if (item.type === 'tool_use') {
        const toolName = item.name || 'unknown';
        const input = item.input || {};

        tools.push(toolName);

        if (input.file_path) {
          files.push(getFileName(input.file_path));
        }
      }
    }
  }

  return { tools: [...new Set(tools)], files: [...new Set(files)] };
}

/**
 * 메시지들을 대화 아이템으로 변환합니다
 */
function convertToConversationItems(messages: Message[]): ConversationItem[] {
  const items: ConversationItem[] = [];

  for (const msg of messages) {
    const isUser = msg.type === 'user' || msg.message?.role === 'user';
    const isAssistant = msg.type === 'assistant' || msg.message?.role === 'assistant';

    if (!isUser && !isAssistant) continue;

    const content = extractTextContent(msg);
    if (!content || isNoiseMessage(content)) continue;

    const { tools, files } = extractToolInfo(msg);

    items.push({
      timestamp: msg.timestamp || new Date().toISOString(),
      role: isUser ? 'user' : 'assistant',
      content: content.length > 1000 ? content.substring(0, 997) + '...' : content,
      toolsUsed: tools.length > 0 ? tools : undefined,
      filesModified: files.length > 0 ? files : undefined,
    });
  }

  return items;
}

/**
 * 대화 내용을 Claude가 읽기 쉬운 형식으로 포맷합니다
 */
function formatConversationForClaude(items: ConversationItem[]): string {
  let output = '';

  for (const item of items) {
    const time = item.timestamp.split('T')[1]?.split('.')[0] || '';
    const role = item.role === 'user' ? '사용자' : 'Claude';

    output += `[${time}] ${role}:\n`;
    output += `${item.content}\n`;

    if (item.filesModified && item.filesModified.length > 0) {
      output += `(수정된 파일: ${item.filesModified.join(', ')})\n`;
    }

    output += '\n---\n\n';
  }

  return output;
}

/**
 * 상태를 로드합니다
 */
function loadState(projectPath: string): StateTracker | null {
  const stateFile = path.join(projectPath, STATE_FILE);

  if (fs.existsSync(stateFile)) {
    try {
      const content = fs.readFileSync(stateFile, 'utf-8');
      return JSON.parse(content);
    } catch (e) {
      return null;
    }
  }

  return null;
}

/**
 * 상태를 저장합니다
 */
function saveState(projectPath: string, state: StateTracker): void {
  const stateFile = path.join(projectPath, STATE_FILE);
  fs.writeFileSync(stateFile, JSON.stringify(state, null, 2));
}

export async function main(_args: string[]): Promise<void> {
  const projectPath = process.cwd();
  const state = loadState(projectPath);
  const lastTimestamp = state?.lastProcessedTimestamp;

  const sessionFiles = findProjectSessionFiles(projectPath);

  if (sessionFiles.length === 0) {
    console.error('대화 내역을 찾을 수 없습니다.');
    console.error('Claude Code로 이 프로젝트에서 대화를 나눈 적이 있는지 확인하세요.');
    process.exit(1);
  }

  let allMessages: Message[] = [];
  for (const file of sessionFiles) {
    const messages = readMessages(file, lastTimestamp);
    allMessages.push(...messages);
  }

  if (allMessages.length === 0) {
    console.log('새로운 대화 내역이 없습니다.');
    process.exit(0);
  }

  // 타임스탬프 순으로 정렬
  allMessages.sort((a, b) => {
    const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return timeA - timeB;
  });

  // 대화 아이템으로 변환
  const conversationItems = convertToConversationItems(allMessages);

  if (conversationItems.length === 0) {
    console.log('정리할 대화 내용이 없습니다.');
    process.exit(0);
  }

  // Claude가 읽을 수 있는 형식으로 출력
  const formattedConversation = formatConversationForClaude(conversationItems);

  console.log('=== 대화 내역 시작 ===\n');
  console.log(formattedConversation);
  console.log('=== 대화 내역 끝 ===\n');

  console.log(`총 ${conversationItems.length}개의 대화가 있습니다.`);
  console.log('\n위 대화 내역을 의미 단위로 묶어서 docs/session-YYYY-MM-DD.md 파일에 정리해주세요.');
  console.log('각 작업은 제목, 수행된 작업(파일명 포함), 결과를 포함해야 합니다.');

  // 상태 업데이트
  const latestTimestamp = allMessages[allMessages.length - 1]?.timestamp || new Date().toISOString();
  const newState: StateTracker = {
    lastProcessedTimestamp: latestTimestamp,
  };
  saveState(projectPath, newState);
}

// CLI 진입점
if (require.main === module) {
  main(process.argv.slice(2)).catch(err => {
    console.error('에러 발생:', err.message);
    process.exit(1);
  });
}
