#!/usr/bin/env node
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface Message {
  role: 'user' | 'assistant';
  content: any;
  timestamp?: string;
  type?: string;
  toolUseResult?: any;
  message?: any;
}

interface StateTracker {
  lastProcessedTimestamp: string;
  totalSessions: number;
}

interface Session {
  userRequests: string[];
  claudeActions: string[];
  errors: string[];
  filesModified: string[];
  toolsUsed: string[];
  timestamp: string;
}

const CLAUDE_HOME = path.join(os.homedir(), '.claude');
const STATE_FILE = '.session-doc-state.json';

/**
 * í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ëŒ€í™” ì„¸ì…˜ íŒŒì¼ ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤
 */
function findProjectSessionFiles(projectPath: string): string[] {
  const normalizedPath = projectPath.replace(/[/.]/g, '-');
  const projectDir = path.join(CLAUDE_HOME, 'projects', normalizedPath);

  if (!fs.existsSync(projectDir)) {
    return [];
  }

  const files = fs.readdirSync(projectDir);
  const sessionFiles = files
    .filter(f => f.endsWith('.jsonl') && !f.startsWith('agent-'))
    .map(f => path.join(projectDir, f))
    .filter(f => fs.statSync(f).size > 0);

  return sessionFiles;
}

/**
 * JSONL íŒŒì¼ì—ì„œ ë©”ì‹œì§€ë“¤ì„ ì½ì–´ì˜µë‹ˆë‹¤
 */
function readMessages(filePath: string, lastTimestamp?: string): Message[] {
  const messages: Message[] = [];
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.trim().split('\n').filter(line => line.trim());

  for (const line of lines) {
    try {
      const msg = JSON.parse(line);

      if (lastTimestamp && msg.timestamp) {
        const msgTime = new Date(msg.timestamp).getTime();
        const lastTime = new Date(lastTimestamp).getTime();
        if (msgTime <= lastTime) {
          continue;
        }
      }

      messages.push(msg);
    } catch (e) {
      continue;
    }
  }

  return messages;
}

/**
 * ì‹œìŠ¤í…œ íƒœê·¸ë¥¼ ì œê±°í•©ë‹ˆë‹¤
 */
function removeSystemTags(text: string): string {
  const patterns = [
    /<ide_opened_file>[\s\S]*?<\/ide_opened_file>/g,
    /<ide_selection>[\s\S]*?<\/ide_selection>/g,
    /<system-reminder>[\s\S]*?<\/system-reminder>/g,
    /<user-prompt-submit-hook>[\s\S]*?<\/user-prompt-submit-hook>/g,
    /<command-message>[\s\S]*?<\/command-message>/g,
    /<command-name>[\s\S]*?<\/command-name>/g,
    /<command-args>[\s\S]*?<\/command-args>/g,
    /<local-command-stdout>[\s\S]*?<\/local-command-stdout>/g,
    /\[Request interrupted by user.*?\]/g,
    /Caveat: The messages below were generated by.*?explicitly asks you to\./gs,
  ];

  let cleaned = text;
  for (const pattern of patterns) {
    cleaned = cleaned.replace(pattern, '');
  }

  return cleaned.trim();
}

/**
 * ë¬´ì˜ë¯¸í•œ ë©”ì‹œì§€ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤
 */
function isNoiseMessage(text: string): boolean {
  if (!text || text.length === 0) return true;

  const noisePatterns = [
    /^#\s*\/session-doc/,
    /^#\s*\/[\w-]+\s*-/,
    /^\[Request interrupted/,
    /^Caveat: The messages below/,
    /^<command-/,
    /^<local-command/,
    /^mkdir -p \.claude\/commands/,
    /^git clone.*session-doc/,
    /^TOOL_PATH=.*session-doc/,
  ];

  return noisePatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * ìœ íš¨í•œ ì‚¬ìš©ì ìš”ì²­ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤
 */
function isValidUserRequest(text: string): boolean {
  if (!text || text.length < 2) return false;

  const invalidPatterns = [
    /^\[Request interrupted/,
    /^<command-/,
    /^<local-command/,
    /^Caveat:/,
    /^#\s*\/[\w-]+\s*-/,  // ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì„¤ëª… (ì˜ˆ: # /session-doc - ...)
  ];

  return !invalidPatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * ë©”ì‹œì§€ì—ì„œ í…ìŠ¤íŠ¸ ì½˜í…ì¸ ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
 */
function extractTextContent(message: Message): string | undefined {
  const content = message.message?.content || message.content;

  if (typeof content === 'string') {
    return removeSystemTags(content);
  }

  if (Array.isArray(content)) {
    const textContent = content
      .filter(c => c.type === 'text')
      .map(c => c.text)
      .join('\n');

    if (textContent.trim()) {
      return removeSystemTags(textContent);
    }
  }

  return undefined;
}

/**
 * íŒŒì¼ ê²½ë¡œì—ì„œ íŒŒì¼ëª…ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤
 */
function getFileName(filePath: string): string {
  return path.basename(filePath);
}

/**
 * ë„êµ¬ í˜¸ì¶œì—ì„œ ì •ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
 */
function extractToolInfo(message: Message): { tools: string[], files: string[], errors: string[] } {
  const tools: string[] = [];
  const files: string[] = [];
  const errors: string[] = [];

  if (message.message?.content && Array.isArray(message.message.content)) {
    for (const item of message.message.content) {
      if (item.type === 'tool_use') {
        const toolName = item.name || 'unknown';
        const input = item.input || {};

        tools.push(toolName);

        if (input.file_path) {
          files.push(getFileName(input.file_path));
        }
      }
    }
  }

  // ì—ëŸ¬ ì¶”ì¶œ
  if (message.toolUseResult?.content) {
    const resultContent = message.toolUseResult.content;
    if (typeof resultContent === 'string' && resultContent.includes('Exit code')) {
      const errorMatch = resultContent.match(/Exit code \d+[\s\S]*?(?=\n\n|$)/);
      if (errorMatch) {
        errors.push(errorMatch[0].substring(0, 200));
      }
    }
  }

  return { tools: [...new Set(tools)], files: [...new Set(files)], errors };
}

/**
 * ë„êµ¬ ì‚¬ìš©ì„ ë¹„ê°œë°œì ì¹œí™”ì ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤
 */
function translateToolUsage(tools: string[], files: string[]): string[] {
  const actions: string[] = [];
  const toolActions: Record<string, string> = {
    'Read': 'íŒŒì¼ í™•ì¸',
    'Write': 'íŒŒì¼ ìƒì„±',
    'Edit': 'íŒŒì¼ ìˆ˜ì •',
    'Bash': 'ëª…ë ¹ì–´ ì‹¤í–‰',
    'Glob': 'íŒŒì¼ ê²€ìƒ‰',
    'Grep': 'ì½”ë“œ ê²€ìƒ‰',
    'Task': 'í•˜ìœ„ ì‘ì—… ìˆ˜í–‰',
    'WebFetch': 'ì›¹ ì •ë³´ ì¡°íšŒ',
    'WebSearch': 'ì›¹ ê²€ìƒ‰',
    'AskUserQuestion': 'ì‚¬ìš©ìì—ê²Œ ì§ˆë¬¸',
    'TodoWrite': 'ì‘ì—… ëª©ë¡ ê´€ë¦¬',
  };

  const usedActions = new Set<string>();

  for (const tool of tools) {
    const action = toolActions[tool] || tool;
    if (!usedActions.has(action)) {
      usedActions.add(action);

      if ((tool === 'Read' || tool === 'Write' || tool === 'Edit') && files.length > 0) {
        const fileList = files.length > 3
          ? `${files.slice(0, 3).join(', ')} ì™¸ ${files.length - 3}ê°œ`
          : files.join(', ');
        actions.push(`${action}: ${fileList}`);
      } else {
        actions.push(action);
      }
    }
  }

  return actions;
}

/**
 * ë©”ì‹œì§€ë“¤ì„ ì„¸ì…˜ìœ¼ë¡œ ê·¸ë£¹í™”í•©ë‹ˆë‹¤
 */
function groupIntoSessions(messages: Message[]): Session[] {
  const sessions: Session[] = [];
  let currentSession: Session | null = null;

  for (const msg of messages) {
    const isUser = msg.type === 'user' || msg.message?.role === 'user';
    const isAssistant = msg.type === 'assistant' || msg.message?.role === 'assistant';

    if (!isUser && !isAssistant) continue;

    const content = extractTextContent(msg);
    if (!content) continue;

    if (isUser) {
      // ìœ íš¨í•œ ì‚¬ìš©ì ìš”ì²­ì¸ì§€ í™•ì¸
      if (!isValidUserRequest(content)) {
        continue;
      }

      // ìƒˆë¡œìš´ ì‚¬ìš©ì ë©”ì‹œì§€ê°€ ì˜¤ë©´ ì´ì „ ì„¸ì…˜ ì €ì¥í•˜ê³  ìƒˆ ì„¸ì…˜ ì‹œì‘
      if (currentSession && currentSession.userRequests.length > 0) {
        sessions.push(currentSession);
      }

      currentSession = {
        userRequests: [],
        claudeActions: [],
        errors: [],
        filesModified: [],
        toolsUsed: [],
        timestamp: msg.timestamp || new Date().toISOString(),
      };

      if (!isNoiseMessage(content)) {
        currentSession.userRequests.push(content);
      }
    } else if (isAssistant && currentSession) {
      const { tools, files, errors } = extractToolInfo(msg);

      currentSession.toolsUsed.push(...tools);
      currentSession.filesModified.push(...files);
      currentSession.errors.push(...errors);

      // Claudeì˜ í…ìŠ¤íŠ¸ ì‘ë‹µ (ì§§ê²Œ)
      if (content && !isNoiseMessage(content) && content.length > 10) {
        const summary = content.length > 300 ? content.substring(0, 297) + '...' : content;
        if (!currentSession.claudeActions.includes(summary)) {
          currentSession.claudeActions.push(summary);
        }
      }
    }
  }

  // ë§ˆì§€ë§‰ ì„¸ì…˜ ì¶”ê°€
  if (currentSession && currentSession.userRequests.length > 0) {
    sessions.push(currentSession);
  }

  return sessions;
}

/**
 * ì„¸ì…˜ ì œëª©ì„ ìƒì„±í•©ë‹ˆë‹¤
 */
function generateSessionTitle(session: Session): string {
  const firstRequest = session.userRequests[0] || '';

  // ì²« 50ìê¹Œì§€ë§Œ ì‚¬ìš©í•˜ê³ , ì¤„ë°”ê¿ˆ ì œê±°
  let title = firstRequest.split('\n')[0].trim();
  if (title.length > 50) {
    title = title.substring(0, 47) + '...';
  }

  return title || 'ì‘ì—…';
}

/**
 * ë§ˆí¬ë‹¤ìš´ ë¬¸ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤
 */
function generateMarkdown(sessions: Session[], startIndex: number): string {
  const today = new Date().toISOString().split('T')[0];

  let markdown = `# Claude Code ì‘ì—… ê¸°ë¡

> ì´ ë¬¸ì„œëŠ” Claude Codeì™€ì˜ ëŒ€í™” ë‚´ì—­ì„ ìë™ìœ¼ë¡œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤.

## ${today}

`;

  let sessionNum = startIndex;

  for (const session of sessions) {
    const title = generateSessionTitle(session);

    markdown += `### ${sessionNum}. ${title}\n\n`;

    // ì‚¬ìš©ì ìš”ì²­
    if (session.userRequests.length > 0) {
      markdown += `**ì‚¬ìš©ì ìš”ì²­:**\n`;
      for (const request of session.userRequests) {
        markdown += `\`\`\`\n${request}\n\`\`\`\n\n`;
      }
    }

    // ìˆ˜í–‰ëœ ì‘ì—…
    const uniqueTools = [...new Set(session.toolsUsed)];
    const uniqueFiles = [...new Set(session.filesModified)];
    const actions = translateToolUsage(uniqueTools, uniqueFiles);

    if (actions.length > 0) {
      markdown += `**ìˆ˜í–‰ëœ ì‘ì—…:**\n`;
      for (const action of actions) {
        markdown += `- ${action}\n`;
      }
      markdown += '\n';
    }

    // ì‹œí–‰ì°©ì˜¤ (ì—ëŸ¬ê°€ ìˆëŠ” ê²½ìš°)
    const uniqueErrors = [...new Set(session.errors)];
    if (uniqueErrors.length > 0) {
      markdown += `**ì‹œí–‰ì°©ì˜¤:**\n`;
      for (const error of uniqueErrors) {
        markdown += `- ${error.split('\n')[0]}\n`;
      }
      markdown += '\n';
    }

    // ê²°ê³¼ (Claudeì˜ ë§ˆì§€ë§‰ ì‘ë‹µì—ì„œ ì¶”ì¶œ)
    if (session.claudeActions.length > 0) {
      const lastAction = session.claudeActions[session.claudeActions.length - 1];
      if (lastAction && lastAction.length > 20) {
        markdown += `**ê²°ê³¼:**\n${lastAction.split('\n')[0]}\n\n`;
      }
    }

    markdown += `---\n\n`;
    sessionNum++;
  }

  return markdown;
}

/**
 * ìƒíƒœë¥¼ ë¡œë“œí•©ë‹ˆë‹¤
 */
function loadState(projectPath: string): StateTracker | null {
  const stateFile = path.join(projectPath, STATE_FILE);

  if (fs.existsSync(stateFile)) {
    try {
      const content = fs.readFileSync(stateFile, 'utf-8');
      return JSON.parse(content);
    } catch (e) {
      return null;
    }
  }

  return null;
}

/**
 * ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤
 */
function saveState(projectPath: string, state: StateTracker): void {
  const stateFile = path.join(projectPath, STATE_FILE);
  fs.writeFileSync(stateFile, JSON.stringify(state, null, 2));
}

export async function main(_args: string[]): Promise<void> {
  const projectPath = process.cwd();
  const state = loadState(projectPath);
  const lastTimestamp = state?.lastProcessedTimestamp;
  const previousTotal = state?.totalSessions || 0;

  console.log('ğŸ“ Claude Code ì„¸ì…˜ ë¬¸ì„œí™” ë„êµ¬\n');
  console.log(`í”„ë¡œì íŠ¸ ê²½ë¡œ: ${projectPath}`);

  if (lastTimestamp) {
    console.log(`ğŸ“Œ ë§ˆì§€ë§‰ ì²˜ë¦¬ ì‹œì : ${new Date(lastTimestamp).toLocaleString()}`);
    console.log(`ğŸ“Š ì´ì „ ì²˜ë¦¬ ê°œìˆ˜: ${previousTotal}ê°œ`);
  }

  const sessionFiles = findProjectSessionFiles(projectPath);

  if (sessionFiles.length === 0) {
    console.error('\nâŒ ëŒ€í™” ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    console.error('   Claude Codeë¡œ ì´ í”„ë¡œì íŠ¸ì—ì„œ ëŒ€í™”ë¥¼ ë‚˜ëˆˆ ì ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
    process.exit(1);
  }

  console.log(`âœ“ ${sessionFiles.length}ê°œì˜ ì„¸ì…˜ íŒŒì¼ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤.`);

  let allMessages: Message[] = [];
  for (const file of sessionFiles) {
    const messages = readMessages(file, lastTimestamp);
    allMessages.push(...messages);
  }

  console.log(`âœ“ ${allMessages.length}ê°œì˜ ìƒˆë¡œìš´ ë©”ì‹œì§€ë¥¼ ì½ì—ˆìŠµë‹ˆë‹¤.`);

  if (allMessages.length === 0) {
    console.log('\nâ„¹ï¸ ìƒˆë¡œìš´ ëŒ€í™” ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.');
    process.exit(0);
  }

  // íƒ€ì„ìŠ¤íƒ¬í”„ ìˆœìœ¼ë¡œ ì •ë ¬
  allMessages.sort((a, b) => {
    const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return timeA - timeB;
  });

  // ì„¸ì…˜ìœ¼ë¡œ ê·¸ë£¹í™”
  const sessions = groupIntoSessions(allMessages);

  console.log(`âœ“ ${sessions.length}ê°œì˜ ëŒ€í™” ì„¸ì…˜ìœ¼ë¡œ ê·¸ë£¹í™”í–ˆìŠµë‹ˆë‹¤.`);

  if (sessions.length === 0) {
    console.log('\nâ„¹ï¸ ì •ë¦¬í•  ëŒ€í™” ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.');
    process.exit(0);
  }

  // ë§ˆí¬ë‹¤ìš´ ìƒì„±
  const today = new Date().toISOString().split('T')[0];
  const docDir = path.join(projectPath, 'docs');
  const docFile = path.join(docDir, `session-${today}.md`);

  // docs ë””ë ‰í† ë¦¬ ìƒì„±
  if (!fs.existsSync(docDir)) {
    fs.mkdirSync(docDir, { recursive: true });
  }

  // ê¸°ì¡´ íŒŒì¼ì´ ìˆìœ¼ë©´ ì¶”ê°€, ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
  let startIndex = 1;
  if (fs.existsSync(docFile)) {
    console.log(`â„¹ï¸ ê¸°ì¡´ ë¬¸ì„œì— ë‚´ìš©ì„ ì¶”ê°€í•©ë‹ˆë‹¤: session-${today}.md`);
    startIndex = previousTotal + 1;

    // ê¸°ì¡´ ë‚´ìš© ì½ê¸°
    const existingContent = fs.readFileSync(docFile, 'utf-8');

    // ìƒˆ ì„¸ì…˜ë§Œ ì¶”ê°€
    let newSessions = '';
    let sessionNum = startIndex;

    for (const session of sessions) {
      const title = generateSessionTitle(session);

      newSessions += `### ${sessionNum}. ${title}\n\n`;

      if (session.userRequests.length > 0) {
        newSessions += `**ì‚¬ìš©ì ìš”ì²­:**\n`;
        for (const request of session.userRequests) {
          newSessions += `\`\`\`\n${request}\n\`\`\`\n\n`;
        }
      }

      const uniqueTools = [...new Set(session.toolsUsed)];
      const uniqueFiles = [...new Set(session.filesModified)];
      const actions = translateToolUsage(uniqueTools, uniqueFiles);

      if (actions.length > 0) {
        newSessions += `**ìˆ˜í–‰ëœ ì‘ì—…:**\n`;
        for (const action of actions) {
          newSessions += `- ${action}\n`;
        }
        newSessions += '\n';
      }

      const uniqueErrors = [...new Set(session.errors)];
      if (uniqueErrors.length > 0) {
        newSessions += `**ì‹œí–‰ì°©ì˜¤:**\n`;
        for (const error of uniqueErrors) {
          newSessions += `- ${error.split('\n')[0]}\n`;
        }
        newSessions += '\n';
      }

      if (session.claudeActions.length > 0) {
        const lastAction = session.claudeActions[session.claudeActions.length - 1];
        if (lastAction && lastAction.length > 20) {
          newSessions += `**ê²°ê³¼:**\n${lastAction.split('\n')[0]}\n\n`;
        }
      }

      newSessions += `---\n\n`;
      sessionNum++;
    }

    // ê¸°ì¡´ ë‚´ìš© ë’¤ì— ì¶”ê°€
    fs.writeFileSync(docFile, existingContent + '\n' + newSessions);
  } else {
    // ìƒˆ íŒŒì¼ ìƒì„±
    const markdown = generateMarkdown(sessions, startIndex);
    fs.writeFileSync(docFile, markdown);
  }

  console.log(`âœ… ë¬¸ì„œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: session-${today}.md`);

  // ìƒíƒœ ì—…ë°ì´íŠ¸
  const latestTimestamp = allMessages[allMessages.length - 1]?.timestamp || new Date().toISOString();
  const newTotal = previousTotal + sessions.length;

  const newState: StateTracker = {
    lastProcessedTimestamp: latestTimestamp,
    totalSessions: newTotal,
  };
  saveState(projectPath, newState);

  console.log(`\nğŸ“Š í†µê³„:`);
  console.log(`   - ì²˜ë¦¬ëœ ì„¸ì…˜: ${sessions.length}ê°œ`);
  console.log(`   - ì´ ëˆ„ì  ì„¸ì…˜: ${newTotal}ê°œ`);
  console.log(`   - ì €ì¥ ìœ„ì¹˜: docs/session-${today}.md`);
  console.log('\nâœ¨ ì™„ë£Œ!');
}

// CLI ì§„ì…ì 
if (require.main === module) {
  main(process.argv.slice(2)).catch(err => {
    console.error('ì—ëŸ¬ ë°œìƒ:', err.message);
    process.exit(1);
  });
}
