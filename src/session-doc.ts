#!/usr/bin/env node
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface Message {
  role: 'user' | 'assistant';
  content: any;
  timestamp?: string;
  type?: string;
  toolUseResult?: any;
  message?: any;
}

interface StateTracker {
  lastProcessedTimestamp: string;
  totalSessions: number;
}

interface Session {
  userRequests: string[];
  claudeActions: string[];
  errors: string[];
  filesModified: string[];
  toolsUsed: string[];
  timestamp: string;
}

const CLAUDE_HOME = path.join(os.homedir(), '.claude');
const STATE_FILE = '.session-doc-state.json';

/**
 * í˜„ì¬ í”„ë¡œì íŠ¸ì˜ ëŒ€í™” ì„¸ì…˜ íŒŒì¼ ê²½ë¡œë¥¼ ì°¾ìŠµë‹ˆë‹¤
 */
function findProjectSessionFiles(projectPath: string): string[] {
  const normalizedPath = projectPath.replace(/[/.]/g, '-');
  const projectDir = path.join(CLAUDE_HOME, 'projects', normalizedPath);

  if (!fs.existsSync(projectDir)) {
    return [];
  }

  const files = fs.readdirSync(projectDir);
  const sessionFiles = files
    .filter(f => f.endsWith('.jsonl') && !f.startsWith('agent-'))
    .map(f => path.join(projectDir, f))
    .filter(f => fs.statSync(f).size > 0);

  return sessionFiles;
}

/**
 * JSONL íŒŒì¼ì—ì„œ ë©”ì‹œì§€ë“¤ì„ ì½ì–´ì˜µë‹ˆë‹¤
 */
function readMessages(filePath: string, lastTimestamp?: string): Message[] {
  const messages: Message[] = [];
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.trim().split('\n').filter(line => line.trim());

  for (const line of lines) {
    try {
      const msg = JSON.parse(line);

      if (lastTimestamp && msg.timestamp) {
        const msgTime = new Date(msg.timestamp).getTime();
        const lastTime = new Date(lastTimestamp).getTime();
        if (msgTime <= lastTime) {
          continue;
        }
      }

      messages.push(msg);
    } catch (e) {
      continue;
    }
  }

  return messages;
}

/**
 * ì‹œìŠ¤í…œ íƒœê·¸ë¥¼ ì œê±°í•©ë‹ˆë‹¤
 */
function removeSystemTags(text: string): string {
  const patterns = [
    /<ide_opened_file>[\s\S]*?<\/ide_opened_file>/g,
    /<ide_selection>[\s\S]*?<\/ide_selection>/g,
    /<system-reminder>[\s\S]*?<\/system-reminder>/g,
    /<user-prompt-submit-hook>[\s\S]*?<\/user-prompt-submit-hook>/g,
    /<command-message>[\s\S]*?<\/command-message>/g,
    /<command-name>[\s\S]*?<\/command-name>/g,
    /<command-args>[\s\S]*?<\/command-args>/g,
    /<local-command-stdout>[\s\S]*?<\/local-command-stdout>/g,
    /\[Request interrupted by user.*?\]/g,
    /Caveat: The messages below were generated by.*?explicitly asks you to\./gs,
  ];

  let cleaned = text;
  for (const pattern of patterns) {
    cleaned = cleaned.replace(pattern, '');
  }

  return cleaned.trim();
}

/**
 * ë¬´ì˜ë¯¸í•œ ë©”ì‹œì§€ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤
 */
function isNoiseMessage(text: string): boolean {
  if (!text || text.length === 0) return true;

  const noisePatterns = [
    /^#\s*\/session-doc/,
    /^#\s*\/[\w-]+\s*-/,
    /^\[Request interrupted/,
    /^Caveat: The messages below/,
    /^<command-/,
    /^<local-command/,
    /^mkdir -p \.claude\/commands/,
    /^git clone.*session-doc/,
    /^TOOL_PATH=.*session-doc/,
  ];

  return noisePatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * ìœ íš¨í•œ ì‚¬ìš©ì ìš”ì²­ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤
 */
function isValidUserRequest(text: string): boolean {
  if (!text || text.length < 2) return false;

  const invalidPatterns = [
    /^\[Request interrupted/,
    /^<command-/,
    /^<local-command/,
    /^Caveat:/,
    /^#\s*\/[\w-]+\s*-/,  // ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ ì„¤ëª… (ì˜ˆ: # /session-doc - ...)
  ];

  return !invalidPatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * ë©”ì‹œì§€ì—ì„œ í…ìŠ¤íŠ¸ ì½˜í…ì¸ ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
 */
function extractTextContent(message: Message): string | undefined {
  const content = message.message?.content || message.content;

  if (typeof content === 'string') {
    return removeSystemTags(content);
  }

  if (Array.isArray(content)) {
    const textContent = content
      .filter(c => c.type === 'text')
      .map(c => c.text)
      .join('\n');

    if (textContent.trim()) {
      return removeSystemTags(textContent);
    }
  }

  return undefined;
}

/**
 * íŒŒì¼ ê²½ë¡œì—ì„œ íŒŒì¼ëª…ë§Œ ì¶”ì¶œí•©ë‹ˆë‹¤
 */
function getFileName(filePath: string): string {
  return path.basename(filePath);
}

/**
 * ë„êµ¬ í˜¸ì¶œì—ì„œ ì •ë³´ë¥¼ ì¶”ì¶œí•©ë‹ˆë‹¤
 */
function extractToolInfo(message: Message): { tools: string[], files: string[], errors: string[] } {
  const tools: string[] = [];
  const files: string[] = [];
  const errors: string[] = [];

  if (message.message?.content && Array.isArray(message.message.content)) {
    for (const item of message.message.content) {
      if (item.type === 'tool_use') {
        const toolName = item.name || 'unknown';
        const input = item.input || {};

        tools.push(toolName);

        if (input.file_path) {
          files.push(getFileName(input.file_path));
        }
      }
    }
  }

  // ì—ëŸ¬ ì¶”ì¶œ
  if (message.toolUseResult?.content) {
    const resultContent = message.toolUseResult.content;
    if (typeof resultContent === 'string' && resultContent.includes('Exit code')) {
      const errorMatch = resultContent.match(/Exit code \d+[\s\S]*?(?=\n\n|$)/);
      if (errorMatch) {
        errors.push(errorMatch[0].substring(0, 200));
      }
    }
  }

  return { tools: [...new Set(tools)], files: [...new Set(files)], errors };
}

/**
 * ë„êµ¬ ì‚¬ìš©ì„ ë¹„ê°œë°œì ì¹œí™”ì ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤
 */
function translateToolUsage(tools: string[], files: string[]): string[] {
  const actions: string[] = [];
  const toolActions: Record<string, string> = {
    'Read': 'íŒŒì¼ í™•ì¸',
    'Write': 'íŒŒì¼ ìƒì„±',
    'Edit': 'íŒŒì¼ ìˆ˜ì •',
    'Bash': 'ëª…ë ¹ì–´ ì‹¤í–‰',
    'Glob': 'íŒŒì¼ ê²€ìƒ‰',
    'Grep': 'ì½”ë“œ ê²€ìƒ‰',
    'Task': 'í•˜ìœ„ ì‘ì—… ìˆ˜í–‰',
    'WebFetch': 'ì›¹ ì •ë³´ ì¡°íšŒ',
    'WebSearch': 'ì›¹ ê²€ìƒ‰',
    'AskUserQuestion': 'ì‚¬ìš©ìì—ê²Œ ì§ˆë¬¸',
    'TodoWrite': 'ì‘ì—… ëª©ë¡ ê´€ë¦¬',
  };

  const usedActions = new Set<string>();

  for (const tool of tools) {
    const action = toolActions[tool] || tool;
    if (!usedActions.has(action)) {
      usedActions.add(action);

      if ((tool === 'Read' || tool === 'Write' || tool === 'Edit') && files.length > 0) {
        const fileList = files.length > 3
          ? `${files.slice(0, 3).join(', ')} ì™¸ ${files.length - 3}ê°œ`
          : files.join(', ');
        actions.push(`${action}: ${fileList}`);
      } else {
        actions.push(action);
      }
    }
  }

  return actions;
}

/**
 * ë©”ì‹œì§€ë“¤ì„ ì„¸ì…˜ìœ¼ë¡œ ê·¸ë£¹í™”í•©ë‹ˆë‹¤
 */
function groupIntoSessions(messages: Message[]): Session[] {
  const sessions: Session[] = [];
  let currentSession: Session | null = null;

  for (const msg of messages) {
    const isUser = msg.type === 'user' || msg.message?.role === 'user';
    const isAssistant = msg.type === 'assistant' || msg.message?.role === 'assistant';

    if (!isUser && !isAssistant) continue;

    const content = extractTextContent(msg);
    if (!content) continue;

    if (isUser) {
      // ìœ íš¨í•œ ì‚¬ìš©ì ìš”ì²­ì¸ì§€ í™•ì¸
      if (!isValidUserRequest(content)) {
        continue;
      }

      // ìƒˆë¡œìš´ ì‚¬ìš©ì ë©”ì‹œì§€ê°€ ì˜¤ë©´ ì´ì „ ì„¸ì…˜ ì €ì¥í•˜ê³  ìƒˆ ì„¸ì…˜ ì‹œì‘
      if (currentSession && currentSession.userRequests.length > 0) {
        sessions.push(currentSession);
      }

      currentSession = {
        userRequests: [],
        claudeActions: [],
        errors: [],
        filesModified: [],
        toolsUsed: [],
        timestamp: msg.timestamp || new Date().toISOString(),
      };

      if (!isNoiseMessage(content)) {
        currentSession.userRequests.push(content);
      }
    } else if (isAssistant && currentSession) {
      const { tools, files, errors } = extractToolInfo(msg);

      currentSession.toolsUsed.push(...tools);
      currentSession.filesModified.push(...files);
      currentSession.errors.push(...errors);

      // Claudeì˜ í…ìŠ¤íŠ¸ ì‘ë‹µ (ì§§ê²Œ)
      if (content && !isNoiseMessage(content) && content.length > 10) {
        const summary = content.length > 300 ? content.substring(0, 297) + '...' : content;
        if (!currentSession.claudeActions.includes(summary)) {
          currentSession.claudeActions.push(summary);
        }
      }
    }
  }

  // ë§ˆì§€ë§‰ ì„¸ì…˜ ì¶”ê°€
  if (currentSession && currentSession.userRequests.length > 0) {
    sessions.push(currentSession);
  }

  return sessions;
}

/**
 * ì›ì‹œ ëŒ€í™” ë°ì´í„°ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ì¶œë ¥í•©ë‹ˆë‹¤
 */
function outputRawData(sessions: Session[]): void {
  const rawData = sessions.map((session, index) => ({
    index: index + 1,
    timestamp: session.timestamp,
    userRequests: session.userRequests,
    toolsUsed: [...new Set(session.toolsUsed)],
    filesModified: [...new Set(session.filesModified)],
    errors: [...new Set(session.errors)],
    claudeResponse: session.claudeActions.length > 0
      ? session.claudeActions[session.claudeActions.length - 1]
      : null,
  }));

  console.log('\n=== RAW_SESSION_DATA_START ===');
  console.log(JSON.stringify(rawData, null, 2));
  console.log('=== RAW_SESSION_DATA_END ===');
}

/**
 * ìƒíƒœë¥¼ ë¡œë“œí•©ë‹ˆë‹¤
 */
function loadState(projectPath: string): StateTracker | null {
  const stateFile = path.join(projectPath, STATE_FILE);

  if (fs.existsSync(stateFile)) {
    try {
      const content = fs.readFileSync(stateFile, 'utf-8');
      return JSON.parse(content);
    } catch (e) {
      return null;
    }
  }

  return null;
}

/**
 * ìƒíƒœë¥¼ ì €ì¥í•©ë‹ˆë‹¤
 */
function saveState(projectPath: string, state: StateTracker): void {
  const stateFile = path.join(projectPath, STATE_FILE);
  fs.writeFileSync(stateFile, JSON.stringify(state, null, 2));
}

export async function main(_args: string[]): Promise<void> {
  const projectPath = process.cwd();
  const state = loadState(projectPath);
  const lastTimestamp = state?.lastProcessedTimestamp;
  const previousTotal = state?.totalSessions || 0;

  console.log('ğŸ“ Claude Code ì„¸ì…˜ ë¬¸ì„œí™” ë„êµ¬\n');
  console.log(`í”„ë¡œì íŠ¸ ê²½ë¡œ: ${projectPath}`);

  if (lastTimestamp) {
    console.log(`ğŸ“Œ ë§ˆì§€ë§‰ ì²˜ë¦¬ ì‹œì : ${new Date(lastTimestamp).toLocaleString()}`);
    console.log(`ğŸ“Š ì´ì „ ì²˜ë¦¬ ê°œìˆ˜: ${previousTotal}ê°œ`);
  }

  const sessionFiles = findProjectSessionFiles(projectPath);

  if (sessionFiles.length === 0) {
    console.error('\nâŒ ëŒ€í™” ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    console.error('   Claude Codeë¡œ ì´ í”„ë¡œì íŠ¸ì—ì„œ ëŒ€í™”ë¥¼ ë‚˜ëˆˆ ì ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.');
    process.exit(1);
  }

  console.log(`âœ“ ${sessionFiles.length}ê°œì˜ ì„¸ì…˜ íŒŒì¼ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤.`);

  let allMessages: Message[] = [];
  for (const file of sessionFiles) {
    const messages = readMessages(file, lastTimestamp);
    allMessages.push(...messages);
  }

  console.log(`âœ“ ${allMessages.length}ê°œì˜ ìƒˆë¡œìš´ ë©”ì‹œì§€ë¥¼ ì½ì—ˆìŠµë‹ˆë‹¤.`);

  if (allMessages.length === 0) {
    console.log('\nâ„¹ï¸ ìƒˆë¡œìš´ ëŒ€í™” ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤.');
    process.exit(0);
  }

  // íƒ€ì„ìŠ¤íƒ¬í”„ ìˆœìœ¼ë¡œ ì •ë ¬
  allMessages.sort((a, b) => {
    const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return timeA - timeB;
  });

  // ì„¸ì…˜ìœ¼ë¡œ ê·¸ë£¹í™”
  const sessions = groupIntoSessions(allMessages);

  console.log(`âœ“ ${sessions.length}ê°œì˜ ëŒ€í™” ì„¸ì…˜ìœ¼ë¡œ ê·¸ë£¹í™”í–ˆìŠµë‹ˆë‹¤.`);

  if (sessions.length === 0) {
    console.log('\nâ„¹ï¸ ì •ë¦¬í•  ëŒ€í™” ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.');
    process.exit(0);
  }

  // ì›ì‹œ ë°ì´í„° ì¶œë ¥ (Claudeê°€ í›„ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡)
  outputRawData(sessions);

  console.log(`\nğŸ“Š í†µê³„:`);
  console.log(`   - ì¶”ì¶œëœ ì„¸ì…˜: ${sessions.length}ê°œ`);
  console.log('\nâœ¨ ë°ì´í„° ì¶”ì¶œ ì™„ë£Œ! Claudeê°€ ì´ ë°ì´í„°ë¥¼ ë¶„ì„í•˜ì—¬ ë¬¸ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.');
}

// CLI ì§„ì…ì 
if (require.main === module) {
  main(process.argv.slice(2)).catch(err => {
    console.error('ì—ëŸ¬ ë°œìƒ:', err.message);
    process.exit(1);
  });
}
