#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const os = require('os');

const CLAUDE_HOME = path.join(os.homedir(), '.claude');
const STATE_FILE = '.log-state.json';

/**
 * 현재 프로젝트의 대화 세션 파일 경로를 찾습니다
 */
function findProjectSessionFiles(projectPath) {
  const normalizedPath = projectPath.replace(/[/.]/g, '-');
  const projectDir = path.join(CLAUDE_HOME, 'projects', normalizedPath);

  if (!fs.existsSync(projectDir)) {
    return [];
  }

  const files = fs.readdirSync(projectDir);
  const sessionFiles = files
    .filter(f => f.endsWith('.jsonl') && !f.startsWith('agent-'))
    .map(f => path.join(projectDir, f))
    .filter(f => fs.statSync(f).size > 0);

  return sessionFiles;
}

/**
 * JSONL 파일에서 메시지들을 읽어옵니다
 */
function readMessages(filePath, lastTimestamp) {
  const messages = [];
  const content = fs.readFileSync(filePath, 'utf-8');
  const lines = content.trim().split('\n').filter(line => line.trim());

  for (const line of lines) {
    try {
      const msg = JSON.parse(line);

      if (lastTimestamp && msg.timestamp) {
        const msgTime = new Date(msg.timestamp).getTime();
        const lastTime = new Date(lastTimestamp).getTime();
        if (msgTime <= lastTime) {
          continue;
        }
      }

      messages.push(msg);
    } catch (e) {
      continue;
    }
  }

  return messages;
}

/**
 * 시스템 태그를 제거합니다
 */
function removeSystemTags(text) {
  const patterns = [
    /<ide_opened_file>[\s\S]*?<\/ide_opened_file>/g,
    /<ide_selection>[\s\S]*?<\/ide_selection>/g,
    /<system-reminder>[\s\S]*?<\/system-reminder>/g,
    /<user-prompt-submit-hook>[\s\S]*?<\/user-prompt-submit-hook>/g,
    /<command-message>[\s\S]*?<\/command-message>/g,
    /<command-name>[\s\S]*?<\/command-name>/g,
    /<command-args>[\s\S]*?<\/command-args>/g,
    /<local-command-stdout>[\s\S]*?<\/local-command-stdout>/g,
    /\[Request interrupted by user.*?\]/g,
    /Caveat: The messages below were generated by.*?explicitly asks you to\./gs,
  ];

  let cleaned = text;
  for (const pattern of patterns) {
    cleaned = cleaned.replace(pattern, '');
  }

  return cleaned.trim();
}

/**
 * 무의미한 메시지인지 확인합니다
 */
function isNoiseMessage(text) {
  if (!text || text.length === 0) return true;

  const noisePatterns = [
    /^#\s*\/log/,
    /^#\s*\/[\w-]+\s*-/,
    /^\[Request interrupted/,
    /^Caveat: The messages below/,
    /^<command-/,
    /^<local-command/,
    /^mkdir -p \.claude\/commands/,
    /^git clone.*log-update/,
    /^TOOL_PATH=.*log-update/,
  ];

  return noisePatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * 유효한 사용자 요청인지 확인합니다
 */
function isValidUserRequest(text) {
  if (!text || text.length < 2) return false;

  const invalidPatterns = [
    /^\[Request interrupted/,
    /^<command-/,
    /^<local-command/,
    /^Caveat:/,
    /^#\s*\/[\w-]+\s*-/,
  ];

  return !invalidPatterns.some(pattern => pattern.test(text.trim()));
}

/**
 * 메시지에서 텍스트 콘텐츠를 추출합니다
 */
function extractTextContent(message) {
  const content = message.message?.content || message.content;

  if (typeof content === 'string') {
    return removeSystemTags(content);
  }

  if (Array.isArray(content)) {
    const textContent = content
      .filter(c => c.type === 'text')
      .map(c => c.text)
      .join('\n');

    if (textContent.trim()) {
      return removeSystemTags(textContent);
    }
  }

  return undefined;
}

/**
 * 파일 경로에서 파일명만 추출합니다
 */
function getFileName(filePath) {
  return path.basename(filePath);
}

/**
 * 도구 호출에서 정보를 추출합니다
 */
function extractToolInfo(message) {
  const tools = [];
  const files = [];
  const errors = [];

  if (message.message?.content && Array.isArray(message.message.content)) {
    for (const item of message.message.content) {
      if (item.type === 'tool_use') {
        const toolName = item.name || 'unknown';
        const input = item.input || {};

        tools.push(toolName);

        if (input.file_path) {
          files.push(getFileName(input.file_path));
        }
      }
    }
  }

  // 에러 추출
  if (message.toolUseResult?.content) {
    const resultContent = message.toolUseResult.content;
    if (typeof resultContent === 'string' && resultContent.includes('Exit code')) {
      const errorMatch = resultContent.match(/Exit code \d+[\s\S]*?(?=\n\n|$)/);
      if (errorMatch) {
        errors.push(errorMatch[0].substring(0, 200));
      }
    }
  }

  return { tools: [...new Set(tools)], files: [...new Set(files)], errors };
}

/**
 * 메시지들을 세션으로 그룹화합니다
 */
function groupIntoSessions(messages) {
  const sessions = [];
  let currentSession = null;

  for (const msg of messages) {
    const isUser = msg.type === 'user' || msg.message?.role === 'user';
    const isAssistant = msg.type === 'assistant' || msg.message?.role === 'assistant';

    if (!isUser && !isAssistant) continue;

    const content = extractTextContent(msg);
    if (!content) continue;

    if (isUser) {
      if (!isValidUserRequest(content)) {
        continue;
      }

      if (currentSession && currentSession.userRequests.length > 0) {
        sessions.push(currentSession);
      }

      currentSession = {
        userRequests: [],
        claudeActions: [],
        errors: [],
        filesModified: [],
        toolsUsed: [],
        timestamp: msg.timestamp || new Date().toISOString(),
      };

      if (!isNoiseMessage(content)) {
        currentSession.userRequests.push(content);
      }
    } else if (isAssistant && currentSession) {
      const { tools, files, errors } = extractToolInfo(msg);

      currentSession.toolsUsed.push(...tools);
      currentSession.filesModified.push(...files);
      currentSession.errors.push(...errors);

      if (content && !isNoiseMessage(content) && content.length > 10) {
        const summary = content.length > 300 ? content.substring(0, 297) + '...' : content;
        if (!currentSession.claudeActions.includes(summary)) {
          currentSession.claudeActions.push(summary);
        }
      }
    }
  }

  if (currentSession && currentSession.userRequests.length > 0) {
    sessions.push(currentSession);
  }

  return sessions;
}

/**
 * 원시 대화 데이터를 JSON 형식으로 출력합니다
 */
function outputRawData(sessions) {
  const rawData = sessions.map((session, index) => ({
    index: index + 1,
    timestamp: session.timestamp,
    userRequests: session.userRequests,
    toolsUsed: [...new Set(session.toolsUsed)],
    filesModified: [...new Set(session.filesModified)],
    errors: [...new Set(session.errors)],
    claudeResponse: session.claudeActions.length > 0
      ? session.claudeActions[session.claudeActions.length - 1]
      : null,
  }));

  console.log('\n=== RAW_SESSION_DATA_START ===');
  console.log(JSON.stringify(rawData, null, 2));
  console.log('=== RAW_SESSION_DATA_END ===');
}

/**
 * 상태를 로드합니다
 */
function loadState(projectPath) {
  const stateFile = path.join(projectPath, STATE_FILE);

  if (fs.existsSync(stateFile)) {
    try {
      const content = fs.readFileSync(stateFile, 'utf-8');
      return JSON.parse(content);
    } catch (e) {
      return null;
    }
  }

  return null;
}

/**
 * 메인 함수
 */
function main() {
  const projectPath = process.cwd();
  const state = loadState(projectPath);
  const lastTimestamp = state?.lastProcessedTimestamp;
  const previousTotal = state?.totalSessions || 0;

  console.log('log-update - Claude Code 세션 문서화 도구\n');
  console.log(`프로젝트 경로: ${projectPath}`);

  if (lastTimestamp) {
    console.log(`마지막 처리 시점: ${new Date(lastTimestamp).toLocaleString()}`);
    console.log(`이전 처리 개수: ${previousTotal}개`);
  }

  const sessionFiles = findProjectSessionFiles(projectPath);

  if (sessionFiles.length === 0) {
    console.error('\n대화 내역을 찾을 수 없습니다.');
    console.error('Claude Code로 이 프로젝트에서 대화를 나눈 적이 있는지 확인하세요.');
    process.exit(1);
  }

  console.log(`${sessionFiles.length}개의 세션 파일을 찾았습니다.`);

  let allMessages = [];
  for (const file of sessionFiles) {
    const messages = readMessages(file, lastTimestamp);
    allMessages.push(...messages);
  }

  console.log(`${allMessages.length}개의 새로운 메시지를 읽었습니다.`);

  if (allMessages.length === 0) {
    console.log('\n새로운 대화 내역이 없습니다.');
    process.exit(0);
  }

  // 타임스탬프 순으로 정렬
  allMessages.sort((a, b) => {
    const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
    const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
    return timeA - timeB;
  });

  // 세션으로 그룹화
  const sessions = groupIntoSessions(allMessages);

  console.log(`${sessions.length}개의 대화 세션으로 그룹화했습니다.`);

  if (sessions.length === 0) {
    console.log('\n정리할 대화 내용이 없습니다.');
    process.exit(0);
  }

  // 원시 데이터 출력 (Claude가 후처리할 수 있도록)
  outputRawData(sessions);

  console.log(`\n통계:`);
  console.log(`   - 추출된 세션: ${sessions.length}개`);
  console.log('\n데이터 추출 완료! Claude가 이 데이터를 분석하여 문서를 생성합니다.');
}

main();
